# Transformable Teacher #
実行時間制限:2 sec / メモリ制限:1024 MB

**問題文**

N人の児童がおり、i番目の児童の身長はHiです。Nは奇数です。

今から、先生であるあなたを含めたN+1人で2人1組をペア組みます。

あなたの目標は、それぞれのペアの身長の差の合計を最小化することです。

すなわち、i番目のペアの身長の組をとしたとき、を最小化したいです。

あなたにはM個変身形態があり、i番目の変身形態での身長はです。

あなたの変身形態とペアの組み方ウィ工夫することで、それぞれのペアの身長の差の合計が最小でいくつにできるか求めてください。


**制約**
+ 入力はすべて整数
+ $$
1 \ge\ left\| S \right\| \ge 2\times 10^5 
$$
+ _S_の各文字は'1'~'9'のいずれか

___
**入力**

入力は以下の形式で標準入力から与えられる。

```
$$_S_$$
```

**出力**

変身形態とペアの組み方を工夫したときの、それぞれのペアの身長の差の合計の最小値を出力せよ。

___
**入力例１**

```
5 3
1 2 3 4 7
1 3 8
```

**出力例１**

```
3
```

身長８の変身形態を選ぶ、身長が(1, 2), (3, 4), (7, 8)のペアを作ると最小になります

**入力例２**

```
7 7
33 60 84 23 16 13 32
96 80 73 76 87 57 29
```

**出力例２**

```
34
```

**入力例３**

```
15 10
554 525 541 814 661 279 668 360 382 175 833 783 688 793 736
496 732 455 306 189 207 976 73 567 759
```

**出力例３**

```
239
```
____

**アイデア**

在任何情况下，要使给定的一个数列两两组合中的差之和最小，则必定是将数列进行排序后，相邻的两个数组合得到组内差之和最小。

因此，该问题可转化为，从给定的一个正整数集合M中选取一个数，放入另一正整数集合N中并对N进行排序，使得相邻两个数组合得到的组内差之和最小。

该问题可通过以下过程暴力求解：

1.将正整数集合N进行排序

2.从正整数集合M中选取一个数，并在排序后数列的合适位置插入

3.计算数列中相邻两个数组合的差并求和

4.重复过程2～3直至遍历完M中的数，选取最小的一个作为结果输出

该思路虽然有效，但是需要的时间复杂度较高，为？，很容易造成运行时间超出，因此需要寻找一个更为简单的方法。

由于集合N中数的个数为整数，则两两组合后，无论方向是从前往后还是从后向前，必定有一个数落单，例如：
```
(13, 16) (23, 30) (32, 60) 84
13 (16, 23) (30, 32) (60, 84)
```
假设在一个长度为n的排序后数列的第i个位置插入，则在i-1之前的数均为从1、2开始为两两组合，在i之后的数则为从n、n-1向前逐一两两组合，仍以上边为例，假设在位置5的地方插入
```
插入前：(13, 16) (23, 30) (32, 60) 84
插入后：(13, 16) (23, 30) (31, 32) (60, 80)
插入前：      13 (16, 23) (30, 32) (60, 84)
```
由此可以看出并不需要对所有数字再进行逐一排序、组合后相加，只需要确定插入数字的插入位置后，根据插入位置是奇是偶来找到与之组合的数，数列中该组合之前和之后的组合内差之和均可提前算出，只需计算该组合的内差即可。

该方法的时间复杂度为

____
**コード**

```
#include <bits/stdc++.h>
using namespace std;

#define FAST ios::sync_with_stdio(false);cin.tie(0);
#define MAX 0x3fffffff;

void solve()
{
  //输入学生个数和老师的变形数
  int n, m;
  cin >> n >> m;
  /输入每个学生的身高和老师各个形态的身高，用向量储存
  vector<int> H(n), W(m);
  for(auto h : H) cin >> h;
  for(auto w : W) cin >> w;
  //对学生身高进行排序
  sort(H.begin(), H.end());
  //建立两个向量，分别用于储存排序后学生身高从前往后和从后向前两两组合的组内差之和
  vector<int> sum1(n + 1 / 2), sum2(n + 1 / 2);
  //从前向后两两组合，最大的数轮空
  for(int i = 0; i < n - 1; i += 2)
  //从后向前两两组合，最小的数轮空
  for(int i = ; i > 0; i -= 2)
  //定义一个变量来储存最小的组内差之和，并遍历向量W
  int ans = MAX;
  for(int w : W)
  {
      //用lower_bound函数来判断w在学生身高向量中的插入位置
      //lower_bound(first, last, &val)通过二分查找返回first到last范围内第一个大于等于val的数的位置
      //upper_bound(first, last, &val)通过二分查找返回first到last范围内第一个大于val的数的位置
      int x = lower_bound(H.begin(), H.end(), w) - H.begin();
      //判断与w相组合的数在前还是在后
      //若w的插入位置l为奇数，说明w应与它之前的数组合，l-1之前的数和l之后的数组内差之后不变
      //若w的插入位置l为偶数，说明w应与它之后的数组合，l之前的数和l+1之后的数组内差之后不变
      if(x & 1) x ^= 1;
      //最终插入后的组内差之和为
      int y = abs(H(x) - w) + sum1[x / 2] + sum2[x / 2];
      if(ans > y) ans = y;
  }
  //输出结果
  cout << ans << endl;
}

int main()
{
  FAST
  int t = 1;
  while(t--)
  {
      solve();
  }
  return 0;
}
```
